<html>

<head>
<title>nCore Development</title>
</head>

<body>
<h1>nCore Development</h1>
<xmp>
Client Application
      |
  hardserver
      |
     HSM	
</xmp>

<h2>Hardserver</h2>
<p>Responsible for routing commands to moudles and returning the reply from the
module to the calling application
</p>

<h2>Generating a key</h2>

<p>Keys generated using the nCore API are generally stored in encrypted form on the hard disk of the computer running the cryptographic application. The key blob that contains the encrypted key information is generated by a module when an application uses the module to generate a key.</p>

<p>A key blob can only be decrypted by a module that has a record of the key that was used to encrypt the information in the key blob. A key blob contains key information and an Access Control List (ACL) which defines who can use the key and what operations the key can be used for.</p>

<h2>Loading a key</h2>

<p>Key information is encrypted in a key blob. To use a key, you first need to load the encrypted key blob into a module. The key blob is decrypted using a key stored on the module, and a handle or object reference to the key is returned to your application.
</p>

<h2>C Client Application Overview</h2>
<p>Connecting to the hardserver and transacting a command</p>
<p>Steps:</p>
<ol>
<li>Define call context structure: NFast_Call_Context</li>
<li>Define memory allocation upcalls: NFast_Malloc_Upcalls</li>
<li>Define thread handling upcalls: NFast_NewThreadUpcalls</li>
<li>Initialize the application handle NFast_Application Passing upcall structures</li>
<li>Connect to the hardserver: NFastApp_Connect</li>
<li>Loop next two steps</li>
<li>Send M_Commands to a module</li>
<li>Wait for M_Reply from module</li>
</ol>

<h3>Declaring a call context</h3>
<p>
Many nCore functions take a call context argument which is passed on to upcalls. The call context structure can be used for any purpose required by an application. The following code shows an example declaration of a call context structure:
</p>
<xmp>
struct NFast_Call_Context
{
	int notused;
};
</xmp>


<h3>Declaring memory allocation upcalls</h3>
<p>
By default the nCore API manages memory by using the standard C library functions malloc, realloc and free . To customize memory management, define a collection of memory allocation upcalls and pass this collection when initializing the application handle. The call context cctx and the transaction context tctx can contain any context information required by your application.

<xmp>
static void *local_malloc(
	size_t nbytes, 
	struct NFast_Call_Context *cctx,
	struct NFast_Transaction_Context *tctx) 
{
	return malloc(nbytes);
}

static void *local_realloc(
	void *ptr,
	size_t nbytes,
	struct NFast_Call_Context *cctx,
	struct NFast_Transaction_Context *tctx) 
{
	return realloc(ptr, nbytes);
}

static void local_free(
	void *ptr,
	struct NFast_Call_Context *cctx,
	struct NFast_Transaction_Context *tctx) 
{
	free(ptr);
}

const NFast_MallocUpcalls mallocupcalls = 
{
	local_malloc,
	local_realloc,
	local_free
};
</xmp>

<h3>Declaring threading upcalls</h3>
<p>
ncthread_upcalls provides a mechanism to specify how threads are implemented on the target platform. If an application needs to use a non-native thread model then the application can either:
</p>
<ul>
<li>fill in an nf_thread_upcalls structure with suitable upcalls and optionally write a translation function xlate_cctx_to_ncthread()</li>
<li>or fill in an NFast_ThreadUpcalls structure, and use NFAPP_IF_THREAD in the code example below instead of NFAPP_IF_NEWTHREAD</li>
</ul>

<xmp>
const NFast_NewThreadUpcalls newthreadupcalls = 
{
	&ncthread_upcalls,
	xlate_cctx_to_ncthread
};

static void xlate_cctx_to_ncthread(
	NFast_AppHandle app,
	struct NFast_Call_Context *cc,
	struct nf_lock_cctx **lcc_r) 
{
	*lcc_r = 0;
}
</xmp>

<h3>Application Initialization</h3>

<xmp>
memset(&app_init_args, 0, sizeof app_init_args);
app_init_args.flags = NFAPP_IF_MALLOC|NFAPP_IF_BIGNUM|NFAPP_IF_NEWTHREAD;
app_init_args.mallocupcalls = &mallocupcalls;
app_init_args.bignumupcalls = &sbn_upcalls;
app_init_args.newthreadupcalls = &newthreadupcalls;
rc = NFastApp_InitEx(&app, &app_init_args, cctx);
</xmp>
<p>One can use NFastApp_Init as well</p>

<h3>Connect to Hardserver</h3>

<code>
rc = NFastApp_Connect(app, &conn, 0, cctx);
if(rc) {
NFast_Perror("error calling NFastApp_Connect", rc);
goto cleanup;
}
</code>

<h3>Cleanup</h3>

<code>
NFastApp_Disconnect(conn, cctx);
NFastApp_Finish(app, cctx);
</code>

<h3>Error handling</h3>
<p>Use</p>
<code>
NFast_Perror<br/>
NFast_StrError
</code>

<h3>Read Security World information</h3>
<xmp>
rc = NFKM_getinfo(app, &worldinfo, cctx);
if(rc) 
{
	NFast_Perror("error calling NFKM_getinfo", rc);
	goto cleanup;
}
</xmp>

<h3>Setting up the authorization mechanism</h3>
<p>The nCore API supports three types of key protection:</p>

<ul>
<li>module protection</li>
<li>pass phrase protection</li>
<li>card set protection</li>
</ul>

<h3>Initialize the Card Loading Library</h3>
<xmp>
rc = RQCard_init(&rqcard, app, conn, worldinfo, cctx);
if(rc) 
{
	NFast_Perror("error calling RQCard_init", rc);
	goto cleanup;
}
</xmp>

<h3>Obtain additional FIPS authorization</h3>
<p>Strict FIPS 140 mode requires authorization for key-generation, which can be
obtained from either an Operator Card or an Administrator Card. 
</p>
<xmp>
rc = RQCard_fips_init(&rqcard, &rqcard_fips);
if(rc) 
{
	NFast_Perror("error calling RQCard_fips_init", rc);
	goto cleanup;
}
</xmp>
<h3>Selecting a user interface</h3>
<p>The following code selects the default user interface for the platform.
<xmp>
rc = RQCard_ui_default(&rqcard);
if(rc) 
{
	NFast_Perror("error calling RQCard_ui_default", rc);
	goto cleanup;
}
</xmp>

<h2>Key generation process</h2>

<ol>
<li>Determine if key is cardset, module or passphase protected</li>
<li>If Cardset protected, goto step 3. Else, goto step 4</li>
<li><a href='#UCSP'>Prompt user for authorizing code on a OCS card. If not valid, do not generate card</a></li>
<li><a href='#SMKP'>Find usable module</a></li>
<li><a href='#PKGACL'>Create ACL (which limits uses of the key)</a></li>
<li><a href='#KC'>Configure key parameters</a></li>
<li><a href='#GK'>Generate Key</a></li>
<li><a href='#WKBC'>Write Key blob and certificate to disk</a></li>
<li><a href='#FM'>Free memory</a></li>
</ol>

<h3 id=UCSP>Using card set protection</h3>
<p>The following code prompts the user to provide a card to protect the key that will be generated. The card set hash populates cardhash when the card-loader completes.</p>
<xmp>
rc = RQCard_logic_ocs_anyone(rqcard, &cardhash, "Insert a card set to protect the new key");
if(rc) 
{
	NFast_Perror("error calling RQCard_logic_ocs_anyone", rc);
	goto cleanup;
}
</xmp>

<h3 id=SMKP>Selecting Module for Key processing</h3>
<p>
The module ID and a key ID for the desired card set on that module are assigned to the moduleid and ltid variables when the card-loader completes. Find the
module info structure corresponding to the moduleid.
</p>
<xmp>
rc = RQCard_whichmodule_anyone(rqcard, &moduleid, &ltid);
if(rc) 
{
	NFast_Perror("error calling RQCard_whichmodule_anyone", rc);
	goto cleanup;
}
rc = rqcard->uf->eventloop(rqcard);
if(rc) 
{
	NFast_Perror("error running card loader", rc);
	goto cleanup;
}

for(n = 0; n < worldinfo->n_modules; ++n)
	if(worldinfo->modules[n]->module == moduleid)
		break;
assert(n < worldinfo->n_modules);
moduleinfo = worldinfo->modules[n];

rc = NFKM_findcardset(app, &cardhash, &cardset, cctx);
if(rc) 
{
	NFast_Perror("error calling NFKM_findcardset", rc);
	goto cleanup;
}
</xmp>

<p>Alternatively you could use the RQCard_whichmodule_specific() function to dictate which module will be used, or the NFKM_getusablemodule() function to use the first available module.</p>

<h3 id=PKGACL>Preparing the key-generation command and ACL</h3>

<p>Set up some command parameters:</p>
<xmp>
command.cmd = Cmd_GenerateKeyPair;
command.args.generatekey.params.type = keytype;
command.args.generatekey.flags = Cmd_GenerateKey_Args_flags_Certify;
command.args.generatekey.module = moduleinfo->module;
</xmp>

<p>Keys are stored with an ACL, which defines which entities can perform operations with the key.
Populate the acl_params variable with the information needed to create the ACL. In this example the application sets the acl_params.f flags parameter to enable key recovery and specify the type of key protection to use.

<xmp>
acl_params.f = NFKM_NKF_RecoveryEnabled|protection;
acl_params.cs = cardset;
</xmp>

<p>
The make ACL blob flags ( acl_params.f ) parameter must be same as the make blob flags parameter ( blob_params.f ), so is set accordingly.</p>
<xmp>
blob_params.f = acl_params.f; 
</xmp>

<p>Define in the ACL for which operations the key is allowed to be used. In this example, the application specifies that the key can be used to sign, verify, encrypt, or decrypt.</p>
<xmp>
acl_params.op_base = (NFKM_DEFOPPERMS_SIGN
                     |NFKM_DEFOPPERMS_VERIFY
                     |NFKM_DEFOPPERMS_ENCRYPT
                     |NFKM_DEFOPPERMS_DECRYPT);
</xmp>
<p>
The application is now ready to generate the ACL:
</p>
<xmp>
rc = NFKM_newkey_makeaclx(app, conn, worldinfo, &acl_params,
                          &command.args.generatekey.acl, cctx);
</xmp>

<h3 id=CK>Configure key parameters</h3>

<p>
Key type specific parameters may need to be specified. For example, if an application is generating a Rijndael key, you need to specify the length of the key required, in bytes:
</p>
<xmp>
command.args.generatekey.params.params.random.lenbytes = 128/8;
</xmp>
<p><b>QUESTION: What parameters must be set for EC keys?</b></p>

<p>
Generating a key in a strict FIPS environment requires that an application obtains authorization (in this case, card set authorization) before attempting to generate a key. It is possible that the card loader has already obtained the necessary authorization from a prior card-loading operation. In this case, the following call will retrieve this authorization:
</p>
<xmp>
rc = RQCard_fips_get(rqcard_fips, moduleinfo->module, &fips140authhandle, 0);
</xmp>
<p>
If this call returns Status_RQCardMustContinue , an application must explicitly attempt to obtain the correct authorization as follows:
</p>
<xmp>
rc = RQCard_fips_logic(rqcard);
if(rc) 
{
	NFast_Perror("error calling RQCard_fips_logic", rc);
	goto cleanup;
}
rc = RQCard_whichmodule_specific(rqcard, moduleinfo->module, 0);
if(rc) 
{
	NFast_Perror("error calling RQCard_whichmodule_anyone", rc);
	goto cleanup;
}
rc = rqcard->uf->eventloop(rqcard);
if(rc) 
{
	NFast_Perror("error running card loader", rc);
	goto cleanup;
}
rc = RQCard_fips_get(rqcard_fips, moduleinfo->module, &fips140authhandle, 0);
</xmp>

<p>Now that the application has obtained the necessary strict FIPS authorization (or cancelled the operation if the correct authorization could not be obtained), it can use the authorization to authorize the creation of the key.
</p>
<xmp>
rc = NFKM_newkey_makeauth(app, worldinfo, &command.flags, &command.certs, fips140authhandle, cctx);
if(rc) 
{
	NFast_Perror("error calling NFKM_newkey_makeauth", rc);
	goto cleanup;
}
</xmp>

<h3>Generate the key</h3>
<xmp>
rc = NFastApp_Transact(conn, cctx, &command, &reply, 0);
rc = check_reply(rc, &reply, "error generating new key");
if(rc)
	goto cleanup;
</xmp>

<h3 id=WKBC>Write Key blob and certificate to disk</h3>

<p>Construct an NFKM_Key key information structure ( keyinfo ) and then save it to disk.</p>
<xmp>
keyinfo->v = 8;
keyinfo->appname = keyident.appname;
keyinfo->ident = keyident.ident;
time(&keyinfo->gentime);
</xmp>

<xmp>
mc = 0;
blob_params.kpriv = reply.reply.generatekey.key;

if(reply.reply.generatekey.flags & Cmd_GenerateKey_Reply_flags_cert_present)
	mc = reply.reply.generatekey.cert;
if(cardset) 
{
	blob_params.lt = ltid;
	blob_params.cs = cardset;
}
blob_params.fips = fips140authhandle;
</xmp>

<p>Configure the blob:</p>
<xmp>
rc = NFKM_newkey_makeblobsx(app, conn, worldinfo, &blob_params, keyinfo, cctx);
if(rc) 
{
	NFast_Perror("error calling NFKM_newkey_makeblobsx", rc);
	goto cleanup;
}
if(mc) 
{
	rc = NFKM_newkey_writecert(app, conn, moduleinfo, blob_params.kpriv, mc, keyinfo, cctx);
	if(rc) 	
	{
		NFast_Perror("error calling NFKM_newkey_writecert", rc);
		goto cleanup;
	}
}
</xmp>

<p>The keyinfo structure is now ready to be saved to disk.</p>

<xmp>
rc = NFKM_recordkey(app, keyinfo, cctx);
if(rc) 
{
	NFast_Perror("error calling NFKM_recordkey", rc);
	goto cleanup;
}
</xmp>

<h3 id=FM>Freeing memory</h3>

<xmp>
NFastApp_FreeACL(app, cctx, 0, &command.args.generatekey.acl);
NFKM_cmd_destroy(app, conn, 0, reply.reply.generatekey.key, "generatekey.key", cctx);
if(ltid) 
	NFKM_cmd_destroy(app, conn, 0, ltid, "ltid", cctx);

if(command.flags & Command_flags_certs_present)
	NFastApp_Free_CertificateList(app, cctx, 0, command.certs);
NFastApp_Free_Reply(app, cctx, 0, &reply);
keyinfo->appname = 0;
keyinfo->ident = 0;
NFKM_freekey(app, keyinfo, cctx);
NFKM_freecardset(app, cardset, cctx);
</xmp>

<h2>Generating an asymmetric key</h2>

<p>The following task are different from generating a symmetric key:</p>
<ul>
<li>command.args.generatekey.flags should be set to Cmd_GenerateKeyPair_Args_flags_Certify</li>
<li>Set up the ACL for both the public and private keys</li>
<li>Set up of the blob</li>
</ul>

</body>

</html>
